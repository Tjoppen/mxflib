/*! \file	mxfwrap.cpp
 *	\brief	Basic MXF essence wrapping utility
 *
 *	\version $Id: mxfwrap.cpp,v 1.43 2008/08/20 13:02:55 matt-beard Exp $
 *
 */
/*
 *	Copyright (c) 2003, Matt Beard
 *	Portions Copyright (c) 2003-5, Metaglue Corporation
 *
 *	This software is provided 'as-is', without any express or implied warranty.
 *	In no event will the authors be held liable for any damages arising from
 *	the use of this software.
 *
 *	Permission is granted to anyone to use this software for any purpose,
 *	including commercial applications, and to alter it and redistribute it
 *	freely, subject to the following restrictions:
 *
 *	  1. The origin of this software must not be misrepresented; you must
 *	     not claim that you wrote the original software. If you use this
 *	     software in a product, an acknowledgment in the product
 *	     documentation would be appreciated but is not required.
 *	
 *	  2. Altered source versions must be plainly marked as such, and must
 *	     not be misrepresented as being the original software.
 *	
 *	  3. This notice may not be removed or altered from any source
 *	     distribution.
 */

#include <mxflib/mxflib.h>

using namespace mxflib;

#include <stdio.h>
#include <iostream>

using namespace std;

// Product GUID and version text for this release
UInt8 ProductGUID_Data[16] = { 0x84, 0x66, 0x14, 0xf3, 0x27, 0x8d, 0xd3, 0x41, 0x86, 0xdc, 0xf0, 0x89, 0xad, 0xef, 0xd0, 0x53 };
string CompanyName = "freeMXF.org";
string ProductName = "mxfwrap file wrapper";
string ProductVersion = "Based on " + LibraryVersion();
string PlatformName = "MXFLib (" + OSName() + ")";

//! Debug flag for KLVLib
int Verbose = 0;

//! Debug flag for MXFLib
static bool DebugMode = false;


// Debug and error messages
#include <stdarg.h>


#ifdef MXFLIB_DEBUG
//! Display a general debug message
void mxflib::debug(const char *Fmt, ...)
{
	if(!DebugMode) return;

	va_list args;

	va_start(args, Fmt);
	vprintf(Fmt, args);
	va_end(args);
}
#endif // MXFLIB_DEBUG

//! Display a warning message
void mxflib::warning(const char *Fmt, ...)
{
	va_list args;

	va_start(args, Fmt);
	printf("Warning: ");
	vprintf(Fmt, args);
	va_end(args);
}

//! Display an error message
void mxflib::error(const char *Fmt, ...)
{
	va_list args;

	va_start(args, Fmt);
	printf("ERROR: ");
	vprintf(Fmt, args);
	va_end(args);
}

// small utility functions that shoud be somewhere else
Int64 TCtoFrames(UInt16 FrameRate, bool DropFrame, UInt16 Hours, UInt16 Mins, UInt16 Secs, UInt16 Frames)
{
	Int64 f = Frames + FrameRate*( Secs + 60*( Mins + 60*Hours ) );

	if( (FrameRate == 30) && DropFrame )
	{
		UInt16 m = Mins + 60*Hours;
		f -= 2*( m - m/10 );
	}

	return f;
}

// non-exported forward declarations
bool ParseCommandLine(int &argc, char **argv);

int Process(	int OutFileNum,
							MXFFilePtr Out,
							EssenceParser::WrappingConfigList WrappingList,
							Rational EditRate,
							UMIDPtr *FPUMID
					 );

struct BodyWrapping
{
	GCWriterPtr Writer;
	GCStreamID EssenceID;
	EssenceParser::WrappingConfigPtr Config;
	FileHandle InFile;
	UInt32 BodySID;

	//! The mode of body partition insertion
	enum PartitionMode { Body_None, Body_Duration, Body_Size } BodyMode;

	UInt32 BodyRate;						//!< The rate of body partition insertion
};
typedef std::list<BodyWrapping> BodyWrappingList;

// OP Qualifier manipulators: ClearStream, SetStream, SetUniTrack, SetMultiTrack
void ClearStream(ULPtr &theUL);
void SetStream(ULPtr &theUL);
void SetUniTrack(ULPtr &theUL);
void SetMultiTrack(ULPtr &theUL);

#ifdef COMPILED_DICT
const bool HaveCompiledDict = true;
// include the autogenerated dictionary
#include "mxflib/dict.h"
#else
const bool HaveCompiledDict = false;
// build an empty dictionary
MXFLIB_DICTIONARY_START(CompileTimeDict)
MXFLIB_DICTIONARY_END
#endif // COMPILED_DICT

//! DM Dictionaries
typedef list<std::string> DMFileList;

namespace
{
	std::string OrthodoxDict = "dict.xml";	//!< Default filename of orthodox Dictionary
	DMFileList DMDicts;						//!< DM Dictionaries
	DMFileList DMMaterialInstances;			//!< DM Instance data files for Material Package
	DMFileList DMFileInstances;			    //!< DM Instance data files for File Package

	// Options
	char InFilenameSet[512];				//!< The set of input filenames
	char InFilename[16][128];				//!< The list of input filenames
	int InFileGangSize;						//!< The number of ganged files to process at a time
	int InFileGangCount;					//!< The number of sets of ganged files to process
	char OutFilenameSet[512];				//!< The set of output filenames
	char OutFilename[16][128];				//!< The output filename
	int OutFileCount;						//!< The number of files to output

	FileHandle InFile[16];					//!< File handles
//	Int64 Duration[16];						//!< Duration of each ganged section of essence

	bool PutTCTrack=true;					//!< If false suppresses the output or Timecode tracks

	bool OPAtom = false;					//!< Is OP-Atom mode being forced?
	bool OPAtom2Part = false;				//!< Has a 2-partition OP-Atom file been requested (only works for VBR)
	bool UpdateHeader= false;				//!< Is the header going to be updated after writing the footer
	bool StreamMode = false;				//!< Wrap in stream-mode
	bool EditAlign = false;					//!< Start new body partitions only at the start of a GOP
	bool UseIndex	= false;				//!< Write complete index tables
	bool SparseIndex = false;				//!< Write sparse index tables (one entry per partition)
	bool SprinkledIndex = false;			//!< Write segmented index tables (one set per partition)
	bool IsolatedIndex = false;				//!< Don't write essence and index in same partition
	bool VeryIsolatedIndex = false;			//!< Don't write metadata and index in same partition

	int SelectedWrappingOption = -1;		//!< Selected wrapping option number: -1 = auto, 0 = list choices (or use SelectedWrappingName)
	std::string SelectedWrappingOptionText;	//!< Selected wrapping option name

//	Position LastEditUnit[128];				//!< Table of last edit units written in sparse index tables (per BodySID)


	// DRAGONS: Temporary option!
	bool FrameGroup = false;				//!< Group all as a frame-wrapped group (in one essence container)

//	int IndexManCount;						//!< Number of index managers in use
//	IndexManagerPtr IndexMan[16];			//!< Index managers per indexed essence container
//	std::list<Position> SparseList[16];		//!< List of edit units to include in sparse index tables (per BodySID)

	Rational ForceEditRate;					//!< Edit rate to try and force

	//! The mode of body partition insertion
	//enum { Body_None, Body_Duration, Body_Size } 
	BodyWrapping::PartitionMode BodyMode = BodyWrapping::Body_None;
	UInt32 BodyRate = 0;					//!< The rate of body partition insertion

	UInt32 HeaderPadding = 0;				//!< The (minimum) number of bytes of padding to leave in the header

	UInt32 KAGSize = 1;						//!< The KAG Size for this file

	// Derived options
	ULPtr OPUL;								//!< The UL of the OP for this file
}


// Operational Pattern Labels
// ==========================

// OP-Atom - #### DRAGONS: Qualifiers need work later!
UInt8 OPAtom_Data[16] = { 0x06, 0x0e, 0x2b, 0x34, 0x04, 0x01, 0x01, 0x02, 0x0d, 0x01, 0x02, 0x01, 0x10, 0x00, 0x00, 0x00 };
ULPtr OPAtomUL = new UL(OPAtom_Data);

// OP1a - #### DRAGONS: Qualifiers may need work!
UInt8 OP1a_Data[16] = { 0x06, 0x0e, 0x2b, 0x34, 0x04, 0x01, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00 };
ULPtr OP1aUL = new UL(OP1a_Data);

// OP1b - #### DRAGONS: Qualifiers need work!
UInt8 OP1b_Data[16] = { 0x06, 0x0e, 0x2b, 0x34, 0x04, 0x01, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x01, 0x02, 0x05, 0x00 };
ULPtr OP1bUL = new UL(OP1b_Data);

// OP2a - #### DRAGONS: Qualifiers need work!
UInt8 OP2a_Data[16] = { 0x06, 0x0e, 0x2b, 0x34, 0x04, 0x01, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00 };
ULPtr OP2aUL = new UL(OP2a_Data);

// OP2b - #### DRAGONS: Qualifiers need work!
UInt8 OP2b_Data[16] = { 0x06, 0x0e, 0x2b, 0x34, 0x04, 0x01, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01, 0x02, 0x02, 0x05, 0x00 };
ULPtr OP2bUL = new UL(OP2b_Data);




//! Should we pause before exit?
bool PauseBeforeExit = false;

// Declare main process function
int main_process(int argc, char *argv[]);

//! Do the main processing and pause if required
int main(int argc, char *argv[]) 
{ 
	int Ret = main_process(argc, argv);

	if(PauseBeforeExit) PauseForInput();

	return Ret;
}

//! Do the main processing (less any pause before exit)
int main_process(int argc, char *argv[])
{
	printf( "MXFlib File Wrapper\n\n" );

	// Parse command line options and exit on error
	ForceEditRate.Numerator = 0;
	if(!ParseCommandLine(argc, argv))
		return 1;

	// Enable FastClipWrap mode - don't do this if random access not available of the output medium
	SetFastClipWrap(true);

	// Load the dictionaries
	int DictLoadResult = 1;

#ifdef ASPA_AAF
	DictLoadResult=LoadDictionary( "aspa-types.xml" );
	if( DictLoadResult ) DictLoadResult=LoadDictionary( "aspa-physdict.xml" );
	if( DictLoadResult ) DictLoadResult=LoadDictionary( "aspa-aafdict.xml" );
	if( DictLoadResult ) DictLoadResult=LoadDictionary( "aspa-aspadict.xml" );
#else
	// if -do= specified, try to load it
	if( !OrthodoxDict.empty() ) DictLoadResult=LoadDictionary( (char *)OrthodoxDict.c_str() );
	// if above failed, or if -dc specified, try the compiled dictionary
	if( HaveCompiledDict && DictLoadResult ) DictLoadResult=LoadDictionary( CompileTimeDict );
#endif

	if( DictLoadResult ) error( "Orthodox dictionary failed to load\n" );

	// load any DM Dictionaries
	DMFileList::iterator dd_it = DMDicts.begin();
	while( !DictLoadResult && dd_it != DMDicts.end() )
	{
		LoadDictionary(*dd_it);
		if( DictLoadResult ) error( "%s failed to load\n", (*dd_it).c_str() );
		dd_it++;
	}

	if( DictLoadResult ) return 1;

	EssenceParser::WrappingConfigList WrappingList;
	EssenceParser::WrappingConfigList::iterator WrappingList_it;

	// The edit rate for all tracks in this file
	Rational EditRate;


	// Identify the wrapping options
	// DRAGONS: Not flexible yet
	int i;
	int InCount = InFileGangSize * InFileGangCount;
	for(i=0; i< InCount; i++)
	{
		// Open the input file
		InFile[i] = FileOpenRead(InFilename[i]);
		if(!FileValid(InFile[i]))
		{
			error("Can't open input file \"%s\"\n", InFilename[i]);
			return 2;
		}

		// Build a list of parsers with their descriptors for this essence
		ParserDescriptorListPtr PDList = EssenceParser::IdentifyEssence(InFile[i]);

		if((!PDList) || (PDList->empty()))
		{
			error("Could not identify the essence in file \"%s\"\n", InFilename[i]);
			return 3;
		}

		// Wrapping config to use
		EssenceParser::WrappingConfigPtr WCP;

		// Auto wrapping selection
		if(SelectedWrappingOption < 0)
		{
			// Select the best wrapping option (only allow multiple stream compound types if not OPAtom)
			if(FrameGroup) WCP = EssenceParser::SelectWrappingOption(!OPAtom, InFile[i], PDList, ForceEditRate, WrappingOption::Frame);
			else WCP = EssenceParser::SelectWrappingOption(!OPAtom, InFile[i], PDList, ForceEditRate);
		}
		else
		// Manual wrapping selection
		{
			// Return code for -w options - used to flag error yet still show options
			int Ret = 0;

			// Get a list of wrapping types (only allow multiple stream compound types if not OPAtom)
			EssenceParser::WrappingConfigList WCList;
			if(FrameGroup) WCList = EssenceParser::ListWrappingOptions(!OPAtom, InFile[i], PDList, ForceEditRate, WrappingOption::Frame);
			else WCList = EssenceParser::ListWrappingOptions(!OPAtom, InFile[i], PDList, ForceEditRate);

			// Ensure that there are enough wrapping options
			if(SelectedWrappingOption > (int)WCList.size())
			{
				error("Wrapping option %d not available\n", SelectedWrappingOption);
				SelectedWrappingOption = 0;
				Ret = 6;
			}

			// List iterator for wrapping selection
			EssenceParser::WrappingConfigList::iterator it;

			// If the caller has requested a list of wrapping options, list them and exit
			if(SelectedWrappingOption == 0)
			{
				// First try and match the text - if this fails we will drop through and list the options
				if(SelectedWrappingOptionText.length())
				{
					EssenceParser::WrappingConfigList::iterator it = WCList.begin();
					while(it != WCList.end())
					{
						std::string Name = (*it)->WrapOpt->Handler->GetParserName();
						if(Name.length() && (*it)->WrapOpt->Name.length()) Name += "::" + (*it)->WrapOpt->Name;

						if(Name == SelectedWrappingOptionText)
						{
							WCP = *it;
							break;
						}

						it++;
					}

					if(!WCP) printf("\nWrapping \"%s\" not available\n", SelectedWrappingOptionText.c_str());
				}

				// The caller has requested a list of wrapping options (or entered an invalid name), list them and exit
				if(!WCP)
				{
					int Opt = 0;
					printf("\nAvailable wrapping options:\n");

					EssenceParser::WrappingConfigList::iterator it = WCList.begin();
					while(it != WCList.end())
					{
						std::string Name = (*it)->WrapOpt->Handler->GetParserName();
						if(Name.length() && (*it)->WrapOpt->Name.length()) Name += "::" + (*it)->WrapOpt->Name;
						
						if(Name.length())
							printf("  %d: {%s} %s\n", (++Opt), Name.c_str(), (*it)->WrapOpt->Description.c_str());
						else
							printf("  %d: %s\n", (++Opt), (*it)->WrapOpt->Description.c_str());

						it++;
					}

					if(Opt == 0) printf("  NONE\n");

					return Ret;
				}
			}
			else
			{
				// Select the nth config
				EssenceParser::WrappingConfigList::iterator it = WCList.begin();
				while(SelectedWrappingOption-- > 1) it++;
				WCP = *it;
			}

			EssenceParser::SelectWrappingOption(WCP);
		}

		if(!WCP)
		{
			error("Could not identify a wrapping mode for the essence in file \"%s\"\n", InFilename[i]);
			return 4;
		}

		// Add this wrapping option
		WrappingList.push_back(WCP);

		// Edit rate for this file
		EditRate = WCP->EditRate;

		// DRAGONS: Once we have set the edit rate for the first file we force it on the rest
		ForceEditRate = EditRate;

		printf("\nSelected wrapping for file \"%s\" : %s\n", InFilename[i], WCP->WrapOpt->Description.c_str());
	}

	// Generate UMIDs for each file package
	UMIDPtr FPUMID[16];								//! UMIDs for each file package (internal or external)
	i = 0;				//  Essence container and track index
	WrappingList_it = WrappingList.begin();
	while(WrappingList_it != WrappingList.end())
	{
		switch((*WrappingList_it)->WrapOpt->GCEssenceType)
		{
		case 0x05: case 0x15:
			FPUMID[i] = MakeUMID(1);
			break;
		case 0x06: case 0x16:
			FPUMID[i] = MakeUMID(2);
			break;
		case 0x07: case 0x17:
			FPUMID[i] = MakeUMID(3);
			break;
		case 0x18: default:
			FPUMID[i] = MakeUMID(4);
			break;
		}

		WrappingList_it++;
		i++;
	}

	// Set any OP qualifiers
	if(!OPAtom)
	{
		if((FrameGroup) || (WrappingList.size() == 1))
		{
			// FIXME: This is wrong!!
			SetUniTrack(OPUL);
			SetStream(OPUL);
		}
		else
		{
			// FIXME: This is wrong!!
			SetMultiTrack(OPUL);
			if(StreamMode) SetStream(OPUL); else ClearStream(OPUL);
		}
	}

	int OutFileNum;
	for(OutFileNum=0; OutFileNum < OutFileCount ; OutFileNum++)
	{
		// Open the output file
		MXFFilePtr Out = new MXFFile;
		if(!Out->OpenNew(OutFilename[OutFileNum]))
		{
			error("Can't open output file \"%s\"\n", OutFilename[OutFileNum]);
			return 5;
		}

		printf( "\nProcessing output file \"%s\"\n", OutFilename[OutFileNum]);

		Process( OutFileNum, Out, WrappingList, EditRate, FPUMID );

		// Close the file - all done!
		Out->Close();
	}

	printf("\nDone\n");

	if( DebugMode ) { fprintf( stderr, "press enter to continue..."); getchar(); }
	return 0;
}


// OP Qualifier manipulators: ClearStream, SetStream, SetUniTrack, SetMultiTrack
void ClearStream(ULPtr &theUL)
{
	UInt8 Buffer[16];

	memcpy(Buffer, theUL->GetValue(), 16);

	if(Buffer[12] > 3) 
	{
		warning("ClearStream() called on specialized OP UL\n");
		return;
	}

	Buffer[14] |= 0x04;

	theUL->Set(Buffer);
}

void SetStream(ULPtr &theUL)
{
	UInt8 Buffer[16];

	memcpy(Buffer, theUL->GetValue(), 16);

	if(Buffer[12] > 3) 
	{
		warning("SetStream() called on specialized OP UL\n");
		return;
	}

	Buffer[14] &= ~0x04;

	theUL->Set(Buffer);
}


void SetUniTrack(ULPtr &theUL)
{
	UInt8 Buffer[16];

	memcpy(Buffer, theUL->GetValue(), 16);

	if(Buffer[12] > 3) 
	{
		warning("SetUniTrack() called on specialized OP UL\n");
		return;
	}

	Buffer[14] &= ~0x08;

	theUL->Set(Buffer);
}

void SetMultiTrack(ULPtr &theUL)
{
	UInt8 Buffer[16];

	memcpy(Buffer, theUL->GetValue(), 16);

	if(Buffer[12] > 3) 
	{
		warning("SetMultiTrack() called on specialized OP UL\n");
		return;
	}

	Buffer[14] |= 0x08;

	theUL->Set(Buffer);
}


//! Parse the command line options
/*!	\return true if all parsed ok, false if an error or none supplied */
bool ParseCommandLine(int &argc, char **argv)
{
	int i;
	for(i=1; i<argc;)
	{
		if (IsCommandLineSwitchPrefix(argv[i][0]))
		{
			char *p = &argv[i][1];					// The option less the '-'
			char Opt = tolower(*p);					// The option itself (in lower case)
			const char *Val = "";					// Any value attached to the option
			if(strlen(p) > 2) Val = &p[2];			// Only set a value if one found

			if(Opt == '1') 
			{
				SetFeature(FeatureVersion1KLVFill);
			}
			else if(Opt == 'a') 
			{
				OPAtom = true;

				// See if the user has requested for a 2-partition OP-Atom file
				if(p[1] == '2') OPAtom2Part = true;
			}
			else if(Opt == 'p')
			{
				// The value is further along as we are using a 2-byte option
				Val++;
				if(tolower(p[1]) == 'd')
				{
					char *temp;
					BodyMode = BodyWrapping::Body_Duration;
					BodyRate = strtoul(Val, &temp, 0);
				}
				else if(tolower(p[1]) == 's')
				{
					char *temp;
					BodyMode = BodyWrapping::Body_Size;
					BodyRate = strtoul(Val, &temp, 0);
				}
				else error("Unknown body partition mode '%c'\n", p[1]);
			}
			else if(Opt == 'e') EditAlign = true;
			else if(Opt == 'f') FrameGroup = true;
			else if(Opt == 's') StreamMode = true;
			else if(Opt == 'v') DebugMode = true;
			else if(Opt == 'i')
			{
				if(tolower(p[1]) == 'i')
				{
					IsolatedIndex = true;
					if(p[2] == '2') VeryIsolatedIndex = true;
				}
				else if(tolower(p[1]) == 'p')
				{
					SparseIndex = true;
				}
				else if(tolower(p[1]) == 's')
				{
					SprinkledIndex = true;
				}
				else
				{
					UseIndex = true;
				}
			}
			else if(Opt == 'h') 
			{
				char *temp;
				HeaderPadding = strtoul(Val, &temp, 0);
			}
			else if(Opt == 'k') 
			{
				char *temp;
				KAGSize = strtoul(Val, &temp, 0);
			}
			else if(Opt == 'z') 
			{
				PauseBeforeExit = true;
			}
			else if(Opt == 'r')
			{
				int N, D; // Use ints in case Int32 is not the same size as "int" on this platform
				if(sscanf(Val,"%d/%d", &N, &D) == 2)
				{
					ForceEditRate.Numerator = N;
					ForceEditRate.Denominator = D;
				}
				else
				{
					error("Invalid edit rate format \"%s\"\n", Val);
				}
			}
			else if(Opt == 'u') 
			{
				UpdateHeader = true;
			}
			else if(Opt == 'w') 
			{
				char *temp;
				char *name=(p+1); // default name
				if( '='==*(p+1) || ':'==*(p+1))	name=p+2; // explicit name
				SelectedWrappingOption = strtoul(name, &temp, 0);
				SelectedWrappingOptionText = name;
			}

			else if(Opt == 'd')
			{
				// -dp=DictionaryPath
				if(tolower(*(p+1))=='p')
				{
					const char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						SetDictionaryPath( name );
					}
				}
				// -dc Use compiled dictionary
				else if(tolower(*(p+1))=='c')
				{
					if( HaveCompiledDict ) OrthodoxDict = "";
				}
				// -do=Orthodox Dictionary
				else if(tolower(*(p+1))=='o')
				{
					const char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						OrthodoxDict = name;
					}
				}
				// DM Dictionary
				else if(tolower(*(p+1))=='d')
				{
					const char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						DMDicts.push_back( std::string(name) );
					}
				}
				// DM Material instance data
				else if(tolower(p[1])=='m' )
				{
					const char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						DMMaterialInstances.push_back( std::string(name) );
					}
				}
				// DM File instance data
				else if(tolower(p[1])=='f' )
				{
					const char *name=""; // default name
					if( '='==*(p+2) || ':'==*(p+2))	name=p+3; // explicit name
					else if( i+1<argc ) name=argv[++i]; // explicit name in next arg

					if( strlen(name) ) 
					{
						DMFileInstances.push_back( std::string(name) );
						// FIXME: add package number selector
					}
				}
			}
			else 
			{
				error("Unknown command-line option %s\n", argv[i]);
			}

			// Remove this option
			int j;
			for(j=i; j<(argc-1); j++) argv[j] = argv[j+1];
			argc--;
		}
		else 
		{
			// Move on to next option
			i++;
		}
	}

	if(argc < 3)
	{
		printf("Usage:    mxfwrap [options] <inputfiles> <mxffile>\n\n");

		printf("Syntax for input files:\n");
		printf("         a,b = file a followed by file b\n");
		printf("         a+b = file a ganged with file b\n");
		printf("     a+b,c+d = file a ganged with file b\n");
		printf("               followed by file c ganged with file d\n\n");

		printf("Note: There must be the same number of ganged files in each sequential set\n");
		printf("      Also all files in each set must be the same duration\n\n");

		printf("Options:\n");
		printf("    -1         = Use a version 1 KLVFill item key\n");
		printf("    -a[2]      = Force OP-Atom (optionally with only 2 partitions if VBR)\n");
		printf("    -e         = Only start body partitions at edit points\n");
		printf("    -f         = Frame-wrap and group in one container\n");
		printf("    -h=<size>  = Leave at least <size> bytes of expansion space in the header\n");
		printf("    -i         = Write index tables (at the end of the file)\n");
		printf("    -ip        = Write sparse index tables with one entry per partition\n");
		printf("    -is        = Write index tables sprinkled one section per partition\n");
		printf("    -ii        = Isolated index tables (don't share partition with essence)\n");
		printf("    -ii2       = Isolated index tables (don't share with essence or metadata)\n");
		printf("    -k=<size>  = Set KAG size (default=1)\n");
		printf("   -pd=<dur>   = Body partition every <dur> frames\n");
		printf("   -ps=<size>  = Body partition roughly every <size> bytes\n");
		printf("                 (early rather than late)\n");
		printf("    -r=<n>/<d> = Force edit rate (if possible)\n");
		printf("    -s         = Interleave essence containers for streaming\n");
		printf("    -u         = Update the header after writing footer\n");
		printf("    -v         = Verbose mode\n");
		printf("    -w         = List available wrapping options (does not build a file)\n");
		printf("    -w=<num>   = Use wrapping option <num>\n");
		printf("    -z         = Pause for input before final exit\n");

		return false;
	}

	InFileGangCount = 1;
	InFileGangSize = 1;

	strncpy(InFilenameSet, argv[1], 510);

	int InCount = 0;
	char *ps = InFilenameSet;
	for(;;)
	{
		char *LastDot = NULL;
		char *pd = InFilename[InCount];

		// Find the position of last dot in the input filename
		while(*ps)
		{
			if(*ps == '.') LastDot = ps;
			if(*ps == ',') { InFileGangCount++; break; }
			if(*ps == '+')
			{
				if(InFileGangCount == 1) InFileGangSize++;
				break;
			}
			*pd++ = *ps++;
		};
		*pd = '\0';
		InCount++;

		// If all files progessed end scan
		if(*ps == '\0') break;

		// Otherwise we found ',' or '+' so skip it
		ps++;
	}

	strncpy(OutFilenameSet, argv[2], 510);
	OutFileCount = 0;
	ps = OutFilenameSet;
	for(;;)
	{
		char *LastDot = NULL;
		char *pd = OutFilename[OutFileCount];

		// Find the position of last dot in the input filename
		while(*ps)
		{
			if(*ps == '.') LastDot = ps;
			if(*ps == ',') { break; }
			if(*ps == '+') { break; }
			*pd++ = *ps++;
		};
		*pd = '\0';
		OutFileCount++;

		// If input filename specified no extension add ".mxf"
		if(LastDot == NULL)	strcpy(pd, ".mxf");

		// If all files progessed end scan
		if(*ps == '\0') break;

		// Otherwise we found ',' or '+' so skip it
		ps++;
	}


	// Detail the options

	debug("** Verbose Mode **\n\n");
	
	printf("KAGSize     = %u\n\n", KAGSize);
	
	if(InFileGangSize == 1)
	{
		if(InFileGangCount == 1) printf("Input file  = %s\n", InFilename[0]);
		else
		{
			printf("Input files = ");
			int i;
			for(i=0; i<InFileGangCount; i++) 
			{ 
				if(i != 0) printf(" then ");
				printf("%s", InFilename[i]);
			}
			printf("\n");
		}
	}
	else
	{
		printf("Input files = ");

		int i;
		for(i=0; i<InFileGangCount; i++) 
		{ 
			if(i != 0) printf(" followed by: ");
			int j;
			for(j=0; j<InFileGangSize; j++) 
			{ 
				if(j != 0) printf(" with ");
				printf("%s", InFilename[i*InFileGangSize + j]);
			}
			printf("\n");
		}
		if(InFileGangCount > 1) printf("\n");
	}

	if(OutFileCount == 1)
	{
		printf("Output file = %s\n\n", OutFilename[0]);
	}
	else
	{
		printf("Output files = ");
		int i;
		for(i=0; i<OutFileCount; i++) 
		{ 
			if(i != 0) printf(" with ");
			printf("%s", OutFilename[i]);
		}
		printf("\n");
	}

	if((SelectedWrappingOption >= 0) && (InFileGangCount * InFileGangSize) != 1)
	{
		error("Selection of wrapping options only currently available with single input files\n");
		SelectedWrappingOption = -1;
	}

	if(OPAtom)
	{
		if(OPAtom2Part)	printf("Output OP = OP-Atom (with only 2 partitions if VBR)\n");
		else printf("Output OP = OP-Atom\n");

		// We will need to update the header
		UpdateHeader = true;

		OPUL = OPAtomUL;

		if((InFileGangCount * InFileGangSize) != OutFileCount) error("OP-Atom can only output a single essence container per file so requires as many output files as input files\n");
		
		if(BodyMode != BodyWrapping::Body_None) 
		{
			warning("Splitting essence across body partitions is forbidden in OP-Atom\n");
			BodyMode = BodyWrapping::Body_None;
		}

		// Force mandatory index table for OP-Atom
		UseIndex = true;
		IsolatedIndex = true;
	}
	else
	{
		if((FrameGroup) || (InFileGangSize == 1))
		{
			if(InFileGangCount == 1) { printf("Output OP = OP1a\n"); OPUL = OP1aUL; }
			else { printf("Output OP = OP2a\n"); OPUL = OP2aUL; }
		}
		else
		{
			if(InFileGangCount == 1) { printf("Output OP = OP1b\n"); OPUL = OP1bUL; }
			else { printf("Output OP = OP2b\n"); OPUL = OP2bUL; }
		}

		if(InFileGangCount > 1) error("Only OP1a and OP1b currently supported\n");
	}

	if(UpdateHeader)
	{
		// We will need some extra space in the header
		if(HeaderPadding == 0) HeaderPadding = 16384;

		printf("An updated header will be written after writing the footer\n");
	}

	if(HeaderPadding)
	{
		if(UpdateHeader) printf("At least %d padding bytes will be left after the initial writing of the header\n", HeaderPadding);
		else printf("At least %d padding bytes will be left after writing the header\n", HeaderPadding);
	}

	if(StreamMode && (InFileGangSize == 1))
	{
		warning("Essence containers will not be interleaved for streaming as none are ganged\n");
		StreamMode = false;
	}

	if(StreamMode) 
	{
		printf("Essence containers will be interleaved for streaming\n");

		if(BodyMode != BodyWrapping::Body_None) 
		{
			warning("Body partitions will be inserted for interleaving - this overrides other body partitioning options\n");
			BodyMode = BodyWrapping::Body_None;
		}

		error("Stream mode not yet supported\n");
	}
	else
	{
		if(BodyMode == BodyWrapping::Body_Duration)
		{
			if(EditAlign)
				printf("A new body partition will be inserted at the first new GOP after each %d frame%s\n", BodyRate, BodyRate==1 ? "" : "s");
			else
				printf("A new body partition will be inserted every %d frame%s\n", BodyRate, BodyRate==1 ? "" : "s");
		}

		if(BodyMode == BodyWrapping::Body_Size)
			printf("Partitions will be limited to %d byte%s (if possible)\n", BodyRate, BodyRate==1 ? "" : "s");
	}

	if(UseIndex) printf("Index tables will be written for each frame wrapped essence container\n");
	if(SprinkledIndex) 
	{
		if(UseIndex) printf("Index tables will also be sprinkled across partitions for each frame wrapped container\n");
		else		 printf("Index tables will be sprinkled across partitions for each frame wrapped essence container\n");
	}
	if(SparseIndex) 
	{
		if(UseIndex || SprinkledIndex) printf("Sparse index tables will also be written for each frame wrapped container\n");
		else						   printf("Sparse index tables will be written for each frame wrapped essence container\n");
	}

	if((UseIndex || SparseIndex || SprinkledIndex) && (IsolatedIndex))
	{
		if(VeryIsolatedIndex) printf("Index table segments will not share a partition with essence or metadata\n");
		else printf("Index table segments will not share a partition with essence\n");
	}

	if(Feature(FeatureVersion1KLVFill))
	{
		printf("KLVFill items will be written with a version 1 key, for compatibility\n");
	}

	// Check for stray parameters as a space in the wrong place can otherise cause us to overwrite input files!
	if(argc > 3)
	{
		printf("\nThere appear to be too many filenames on the command line\n");
		return false;
	}

	return true;
}



//! Short term hack to allow per-BodySID GCWriters
/*! DRAGONS: This needs to be tidied a little when there is time! */
GCWriterPtr AddGCWriter(std::map<int, GCWriterPtr> &Map, MXFFilePtr &File, int BodySID)
{
	// First try and return an existing GCWriter
	std::map<int, GCWriterPtr>::iterator it = Map.find(BodySID);
	if(it != Map.end()) return (*it).second;

	// Insert a new writer
	Map.insert(std::map<int, GCWriterPtr>::value_type(BodySID, new GCWriter(File, BodySID)));

	// Find and return the new entry (not hugely efficient!)
	it = Map.find(BodySID);

	return (*it).second;
}


//! Set the index options for a given body stream
void SetStreamIndex(BodyStreamPtr &ThisStream, bool isCBR)
{
	// Set CBR indexing flags
	if(isCBR)
	{
		// If this stream is not CBR indexable don't set any flags
		if(ThisStream->GetSource()->GetBytesPerEditUnit() == 0) return;

		if(IsolatedIndex)
		{
			if(UseIndex) ThisStream->SetIndexType( (BodyStream::IndexType) ( BodyStream::StreamIndexCBRHeaderIsolated 
																		   | BodyStream::StreamIndexCBRFooter) );
		}
		else
		{
			if(UseIndex) ThisStream->SetIndexType( (BodyStream::IndexType) ( BodyStream::StreamIndexCBRHeader 
																		   | BodyStream::StreamIndexCBRBody 
																		   | BodyStream::StreamIndexCBRFooter) );
		}
	}
	// Set VBR indexing flags
	else
	{
		// If this stream is not VBR indexable don't set any flags
		if(!ThisStream->GetSource()->CanIndex()) return;

		if(UseIndex) ThisStream->AddIndexType(BodyStream::StreamIndexFullFooter);
		if(SparseIndex) ThisStream->AddIndexType(BodyStream::StreamIndexSparseFooter);
		if(SprinkledIndex) 
		{
			if(IsolatedIndex) ThisStream->AddIndexType(BodyStream::StreamIndexSprinkledIsolated);
			else ThisStream->AddIndexType(BodyStream::StreamIndexSprinkled);
		}
	}
}


//! Set the wrapping type for a stream
void SetStreamWrapType(BodyStreamPtr &ThisStream, WrappingOption::WrapType Type)
{
	if(Type == WrappingOption::Frame) ThisStream->SetWrapType(BodyStream::StreamWrapFrame);
	else if(Type == WrappingOption::Clip) ThisStream->SetWrapType(BodyStream::StreamWrapClip);
	else ThisStream->SetWrapType(BodyStream::StreamWrapOther);
}


namespace
{
	//! Structure holding info about each essence track
	class EssenceTrackInfo : public RefCount<EssenceTrackInfo>
	{
	public:
		GCStreamID EssenceID;						//!< Essence stream ID
		TrackPtr MPTrack;							//!< Material Package track
		TrackPtr FPTrack;							//!< File Package track
		SourceClipPtr MPClip;						//!< Material Package SourceClip
		SourceClipPtr FPClip;						//!< File Package SourceClip

	public:
		EssenceTrackInfo() { }
		~EssenceTrackInfo() { }
	};

	//! Smart pointer to an EssenceTrackInfo
	typedef SmartPtr<EssenceTrackInfo> EssenceTrackInfoPtr;

	//! List of Smart pointers to EssenceTrackInfo objects
	typedef std::list<EssenceTrackInfoPtr> EssenceTrackInfoList;
}


//! Process an output file
int Process(	int OutFileNum,
							MXFFilePtr Out,
							EssenceParser::WrappingConfigList WrapCfgList,
							Rational EditRate,
							UMIDPtr *FPUMID
					 )

{
	EssenceParser::WrappingConfigList::iterator WrapCfgList_it;

	int Ret = 0;

	/* Step: Create a set of header metadata */

	MetadataPtr MData = new Metadata();
	ASSERT(MData);
	ASSERT(MData->Object);

#if defined FORCEGCMULTI 
	// 377M MultipleDescriptor (D.5) requires an EssenceContainer label (D.1), which must be this
	// degenerate label (see mxfIG FAQ). Therefore the degenerate value must also appear in the
	// Header (A.1) and partition pack...
	// also, explicitly required by AS-CNN sec 2.1.6

	// DRAGONS: Why is this here? It unconditionally adds "Used to describe multiple wrappings not
	//          otherwise covered under the MXF Generic Container node" to all MXF files!!

	// Assume we are doing GC
	ULPtr GCUL = new UL( mxflib::GCMulti_Data );
	MData->AddEssenceType( GCUL );
#endif

	// Set the OP label
	// If we are writing OP-Atom we write the header as OP1a initially as another process
	// may try to read the file before it is complete and then it will NOT be a valid OP-Atom file
	// DRAGONS: This should be OPxx which matches the number of file packages...
	if(OPAtom) MData->SetOP(OP1aUL); else MData->SetOP(OPUL);

	// Work out the edit rate from the descriptor
	bool DropFrame = 0;
	UInt32 FrameRate = EditRate.Numerator;

	// Use drop-frame for any non-integer frame rate
	if(EditRate.Denominator > 1)
	{
		// This is an integer equivalent of FrameRate = floor((FrameRate + 0.5) / Denominator)
		FrameRate += EditRate.Denominator - 1;
		FrameRate /= EditRate.Denominator;

		DropFrame = true;
	}

	// Build the Material Package
	// FIXME: We should really try and determine the UMID type rather than cop-out!
	UMIDPtr pUMID = MakeUMID( 0x0d ); // mixed type

	PackagePtr MaterialPackage = MData->AddMaterialPackage("A Material Package", pUMID);

	MData->SetPrimaryPackage(MaterialPackage);		// This will be overwritten for OP-Atom

	// Add any DM Material Instances
	DMFileList::iterator dm_it = DMMaterialInstances.begin();
	while( dm_it != DMMaterialInstances.end() )
	{
		// TODO: AddDM( MaterialPackage, (*dm_it).c_str() );
		dm_it++;
	}

	TrackPtr MPTimecodeTrack;
	if(PutTCTrack)
		MPTimecodeTrack= MaterialPackage->AddTimecodeTrack(EditRate);

	TimecodeComponentPtr MPTimecodeComponent ;
	if(PutTCTrack)
		MPTimecodeComponent= MPTimecodeTrack->AddTimecodeComponent(FrameRate, DropFrame, 0 );

	// Build the body writer
	BodyWriterPtr Writer = new BodyWriter(Out);

	// Set the writer's general parameters
	Writer->SetKAG(KAGSize);
	Writer->SetForceBER4(true);

	// SMPTE 390M does not recommend placing Essence in the header partition
	if(OPAtom && (!OPAtom2Part))
	{
		// Index data can't share with metadata if very-isolated, essence can never share with metadata
		Writer->SetMetadataSharing(!VeryIsolatedIndex, false);
	}
	else
	{
		// Index data can't share with metadata if very-isolated but essence can always share with metadata
		Writer->SetMetadataSharing(!VeryIsolatedIndex, true);
	}

	// Build the File Packages and all essence tracks

	EssenceTrackInfoList TrackInfoList;				//!< List of all essence tracks

	BodyStreamList Streams;							//!< BodyStream for each stream being built (master stream if frame-grouping)

	PackagePtr FilePackage;							//!< The current file package

	unsigned int PrevEssenceType = 0;

	// FIXME: Remove this array - find a better way
	TimecodeComponentPtr FPTimecodeComponent[16];	//!< Timecode component in the file package

	size_t TracksPerGang = 0;						//!< Count of the number of MP or FP tracks in a complete gang (set once the first gang is written)

	int iTrack = 0;									//!<  Essence file index
	WrapCfgList_it = WrapCfgList.begin();
	while(WrapCfgList_it != WrapCfgList.end())
	{
		// Add a new essence track info item
		TrackInfoList.push_back(new EssenceTrackInfo);

		TrackPtr FPTimecodeTrack;

		// Write File Packages except for externally ref'ed essence in OP-Atom
		bool WriteFP = (!OPAtom) || (iTrack == OutFileNum);

		if( OPAtom )
		{
			if(WriteFP) // (iTrack == OutFileNum)
			{
				// Get the source for this essence
				EssenceSourcePtr Source = (*WrapCfgList_it)->WrapOpt->Handler->GetEssenceSource(InFile[iTrack], (*WrapCfgList_it)->Stream );

				// Build a stream object to write
				Streams.push_back(new BodyStream(iTrack + 1, Source));
				SetStreamWrapType(Streams.back(), (*WrapCfgList_it)->WrapOpt->ThisWrapType);

				// Force edit-unit align if requested
				if(EditAlign) Streams.back()->SetEditAlign(true);

				// Set indexing options for this stream
				if(UseIndex || SparseIndex || SprinkledIndex)
				{
					if((*WrapCfgList_it)->WrapOpt->CBRIndex) SetStreamIndex(Streams.back(), true); 
					else
					{
						if((*WrapCfgList_it)->WrapOpt->ThisWrapType == WrappingOption::Frame)
						{
							SetStreamIndex(Streams.back(), false);
						}
						else
						{
							warning("VBR Indexing only currently supported for frame wrapping\n");
						}
					}
				}

				// Add this stream to the body writer
				Writer->AddStream(Streams.back());

				// The source will have be allocated a StreamID when added to the BodyStream - we need that for track linking later
				TrackInfoList.back()->EssenceID = Source->GetStreamID();

				// Add the file package
				FilePackage = MData->AddFilePackage(iTrack+1, std::string("File Package: ") + (*WrapCfgList_it)->WrapOpt->Description, FPUMID[iTrack]);

				// Ensure it has a timecode track
				if(PutTCTrack)
				{
					FPTimecodeTrack = FilePackage->AddTimecodeTrack(EditRate);
					FPTimecodeComponent[iTrack] = FPTimecodeTrack->AddTimecodeComponent(FrameRate, DropFrame, TCtoFrames( FrameRate, DropFrame, 1, 0, 0, 0 ) );
				}
			}
		}
		else if( FrameGroup ) // !OPAtom
		{
			// Get the source for this essence
			EssenceSourcePtr Source = (*WrapCfgList_it)->WrapOpt->Handler->GetEssenceSource(InFile[iTrack], (*WrapCfgList_it)->Stream );

			if(iTrack == 0)
			{
				// Build a stream object to write
				Streams.push_back(new BodyStream(iTrack + 1, Source));

				// DRAGONS: This should always end up as frame wrapping - but in the future "Other" may be used
				SetStreamWrapType(Streams.back(), (*WrapCfgList_it)->WrapOpt->ThisWrapType);

				// Force edit-unit align if requested
				if(EditAlign) Streams.back()->SetEditAlign(true);
			}
			else
			{
				// Add this sub-stream
				Streams.front()->AddSubStream(Source);
				
				// Add a copy of the stream pointer so that the Nth entry always points to the BodyStream handling the Nth stream
				Streams.push_back(Streams.front());
			}

			// Set indexing options for this stream
			// FIXME: This needs to be done only once based on CBR or VBR nature of combined group!!
			if(UseIndex || SparseIndex || SprinkledIndex)
			{
				if((*WrapCfgList_it)->WrapOpt->CBRIndex) SetStreamIndex(Streams.back(), true); 
				else
				{
					if((*WrapCfgList_it)->WrapOpt->ThisWrapType == WrappingOption::Frame)
					{
						SetStreamIndex(Streams.back(), false);
					}
					else
					{
						warning("VBR Indexing only currently supported for frame wrapping\n");
					}
				}
			}

			// Add this stream to the body writer (first pass only)
			if(iTrack == 0) Writer->AddStream(Streams.front());

			// The source will have be allocated a StreamID when added to the BodyStream - we need that for track linking later
			TrackInfoList.back()->EssenceID = Source->GetStreamID();

			PrevEssenceType = (*WrapCfgList_it)->WrapOpt->GCEssenceType;

			if( iTrack == 0 )
			{
				FilePackage = MData->AddFilePackage(iTrack+1, std::string("File Package: ") + (*WrapCfgList_it)->WrapOpt->Description, FPUMID[iTrack]);

				FPTimecodeTrack = FilePackage->AddTimecodeTrack(EditRate);
				FPTimecodeComponent[iTrack] = FPTimecodeTrack->AddTimecodeComponent(FrameRate, DropFrame, TCtoFrames( FrameRate, DropFrame, 1, 0, 0, 0 ) );
			}
		}
		else // !OPAtom, !FrameGroup
		{
			// Get the source for this essence
			EssenceSourcePtr Source = (*WrapCfgList_it)->WrapOpt->Handler->GetEssenceSource(InFile[iTrack], (*WrapCfgList_it)->Stream );

			// Build a stream object to write
			Streams.push_back(new BodyStream(iTrack + 1, Source));
			SetStreamWrapType(Streams.back(), (*WrapCfgList_it)->WrapOpt->ThisWrapType);

			// Force edit-unit align if requested
			if(EditAlign) Streams.back()->SetEditAlign(true);

			// Set indexing options for this stream
			if(UseIndex || SparseIndex || SprinkledIndex)
			{
				if((*WrapCfgList_it)->WrapOpt->CBRIndex) SetStreamIndex(Streams.back(), true); 
				else
				{
					if((*WrapCfgList_it)->WrapOpt->ThisWrapType == WrappingOption::Frame)
					{
						SetStreamIndex(Streams.back(), false);
					}
					else
					{
						warning("VBR Indexing only currently supported for frame wrapping\n");
					}
				}
			}

			// Add this stream to the body writer
			Writer->AddStream(Streams.back());

			// The source will have be allocated a StreamID when added to the BodyStream - we need that for track linking later
			TrackInfoList.back()->EssenceID = Source->GetStreamID();

			// DRAGONS: Why if(true) ? To match the code structure in the other two cases above
			if( true )
			{
				FilePackage = MData->AddFilePackage(iTrack+1, std::string("File Package: ") + (*WrapCfgList_it)->WrapOpt->Description, FPUMID[iTrack]);

				FPTimecodeTrack = FilePackage->AddTimecodeTrack(EditRate);
				FPTimecodeComponent[iTrack] = FPTimecodeTrack->AddTimecodeComponent(FrameRate, DropFrame, TCtoFrames( FrameRate, DropFrame, 1, 0, 0, 0 ) );
			}
		}

		/* We now add tracks for this essence stream - multiple streams if we have a DV-style compound essence source */
		
		//! The current descriptor
		MDObjectPtr ThisDescriptor = (*WrapCfgList_it)->EssenceDescriptor;

		//! The sub-descriptor batch, if this is a multiple stream, else NULL
		MDObjectPtr SubDescriptors;

		//! Iterator for scanning the sub-descriptor batch, if this is a multiple stream
		// DRAGONS: Here we initialize the iterator with a generic MDObject::iterator::end() value that won't
		//          ever be used, but keeps strict compilers from complaining it is uninitialized
		MDObject::iterator SubDescriptorsIt = ThisDescriptor->end();

		//! The index number of the sub track within this multiple essence stream, zero for the first
		size_t SubTrackIndex = 0;

		//! Is this essense stream a multiplexed type
		if((*WrapCfgList_it)->EssenceDescriptor->IsA(MultipleDescriptor_UL))
		{
			SubDescriptors = ThisDescriptor[SubDescriptorUIDs_UL];
			if(SubDescriptors)
			{
				SubDescriptorsIt = SubDescriptors->begin();
			}
		}

		/* Locate the track info for the material package track containing this essence (or the first sub-stream of) */
		/* This will be the current track info if we are in the first gang, otherwise we locate the corresponding track in the first gang */

		EssenceTrackInfoList::iterator TrackInfoIt;
		if(iTrack < InFileGangSize)
		{
			TrackInfoIt = TrackInfoList.end();
			TrackInfoIt--;
		}
		else
		{
			ASSERT(TracksPerGang);

			// This gives us a value that is the track number in the track info list of the corresponding first gang track (0 being the first)
			size_t TrackPos = (TrackInfoList.size() - 1) % TracksPerGang;

			TrackInfoIt = TrackInfoList.begin();
			while(TrackPos--) TrackInfoIt++;
		}

		for(;;)
		{
			// Locate the descriptor if this is a multiple essence stream
			if(SubDescriptors)
			{
				// All done?
				if(SubDescriptorsIt == SubDescriptors->end()) break;

				ThisDescriptor = (*SubDescriptorsIt).second->GetLink();
			
				if(!ThisDescriptor)
				{
					error("Broken link in multiple descriptor for %s\n", (*WrapCfgList_it)->WrapOpt->Description.c_str());
					SubDescriptorsIt++;

					// DRAGONS: We don't increment SubTrackIndex here as we have not added any tracks for this sub-stream
					continue;
				}

				// If this is not the fist sub-stream then we will need to duplicate the track info structure for the new sub-track
				if(SubTrackIndex)
				{
					TrackInfoList.push_back(new EssenceTrackInfo(*(TrackInfoList.back())));
				}
			}

			// Now that we have possibly added a new entry to the end of the track info list, 
			// it is safe to step back to the last entry if we stepped off the end last time through the list.
			// See the note at the end of this loop
			if(TrackInfoIt == TrackInfoList.end()) TrackInfoIt--;


			/* Determine what type of tracks to add */
			/* Note: We only add material package tracks on the first gang, and we only add file package tracks if we are writing a file package */
			
			if(ThisDescriptor->IsA(GenericPictureEssenceDescriptor_UL))
			{
				if(iTrack < InFileGangSize) TrackInfoList.back()->MPTrack = MaterialPackage->AddPictureTrack(EditRate);
				if(WriteFP) TrackInfoList.back()->FPTrack = FilePackage->AddPictureTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
			}
			else
			if(ThisDescriptor->IsA(GenericSoundEssenceDescriptor_UL))
			{
				if(iTrack < InFileGangSize) TrackInfoList.back()->MPTrack = MaterialPackage->AddSoundTrack(EditRate);
				if(WriteFP) TrackInfoList.back()->FPTrack = FilePackage->AddSoundTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
			}
			else
			if(ThisDescriptor->IsA(GenericDataEssenceDescriptor_UL))
			{
				if(iTrack < InFileGangSize) TrackInfoList.back()->MPTrack = MaterialPackage->AddDataTrack(EditRate);
				if(WriteFP) TrackInfoList.back()->FPTrack = FilePackage->AddDataTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
			}
			else
			{
				// If we can't determine the track type from the descriptor, use the essence type
				switch((*WrapCfgList_it)->WrapOpt->GCEssenceType)
				{
				case 0x05: case 0x15:
					if(iTrack < InFileGangSize) TrackInfoList.back()->MPTrack = MaterialPackage->AddPictureTrack(EditRate);
					if(WriteFP) TrackInfoList.back()->FPTrack = FilePackage->AddPictureTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
					break;
				case 0x06: case 0x16:
					if(iTrack < InFileGangSize) TrackInfoList.back()->MPTrack = MaterialPackage->AddSoundTrack(EditRate);
					if(WriteFP) TrackInfoList.back()->FPTrack = FilePackage->AddSoundTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
					break;
				case 0x07: case 0x17: default:
					if(iTrack < InFileGangSize) TrackInfoList.back()->FPTrack = FilePackage->AddDataTrack(Streams.back()->GetTrackNumber(TrackInfoList.back()->EssenceID), EditRate);
					if(WriteFP) TrackInfoList.back()->MPTrack = MaterialPackage->AddDataTrack(EditRate);
					break;
				}
			}

			// Add a single Component to this Track of the Material Package
			TrackInfoList.back()->MPClip = (*TrackInfoIt)->MPTrack->AddSourceClip();

			// Add a single Component to this Track of the File Package
			if(WriteFP) TrackInfoList.back()->FPClip = TrackInfoList.back()->FPTrack->AddSourceClip();

			// Add the file descriptor to the file package
			// except for externally ref'ed essence in OP-Atom
			if( OPAtom )
			{
				// Write a File Descriptor only on the internally ref'ed Track 
				if( WriteFP ) // (iTrack == OutFileNum)
				{
					ThisDescriptor->SetUInt(LinkedTrackID_UL, TrackInfoList.back()->FPTrack->GetUInt(TrackID_UL));
					FilePackage->AddChild(Descriptor_UL)->MakeRef((*WrapCfgList_it)->EssenceDescriptor);

					// Add the essence type
					MData->AddEssenceType((*WrapCfgList_it)->WrapOpt->WrappingUL);

					if((*WrapCfgList_it)->EssenceDescriptor->IsA(MultipleDescriptor_UL))
					{
						// Ensure that we have flagged a multiple descriptor if one is used
						ULPtr GCUL = new UL( mxflib::GCMulti_Data );
						MData->AddEssenceType( GCUL );
					}

					// Link the MP to the FP
					TrackInfoList.back()->MPClip->MakeLink(TrackInfoList.back()->FPTrack, 0);
				}
				else // (!WriteFP)
				{
					// Link the MP to the external FP
					// DRAGONS: We must assume what the linked track will be... track 2
					//          This is because there will be only two tracks, track 1 will be timecode, track 2 will be the essence
					// FIXME: What if there is no timecode track?
					TrackInfoList.back()->MPClip->MakeLink(FPUMID[iTrack], 2, 0);
				}
			}
			else if( FrameGroup ) // !OPAtom
			{
				// write a MultipleDescriptor only on the first Iteration
				if( iTrack == 0 )
				{
						MDObjectPtr MuxDescriptor = new MDObject(MultipleDescriptor_UL);
						MuxDescriptor->AddChild(SampleRate_UL)->SetInt("Numerator",(*WrapCfgList_it)->EssenceDescriptor[SampleRate_UL]->GetInt("Numerator"));
						MuxDescriptor->AddChild(SampleRate_UL)->SetInt("Denominator",(*WrapCfgList_it)->EssenceDescriptor[SampleRate_UL]->GetInt("Denominator"));

						MuxDescriptor->AddChild(EssenceContainer_UL,false)->SetValue(DataChunk(16,mxflib::GCMulti_Data));

						MuxDescriptor->AddChild(SubDescriptorUIDs_UL);
						FilePackage->AddChild(Descriptor_UL)->MakeRef(MuxDescriptor);

						// Ensure that we have flagged a multiple descriptor
						ULPtr GCUL = new UL( mxflib::GCMulti_Data );
						MData->AddEssenceType( GCUL );
				}

				// Write a SubDescriptor
				ThisDescriptor->SetUInt(LinkedTrackID_UL, TrackInfoList.back()->FPTrack->GetUInt(TrackID_UL));
				
				MDObjectPtr MuxDescriptor = FilePackage[Descriptor_UL]->GetLink();

				MuxDescriptor[SubDescriptorUIDs_UL]->AddChild()->MakeRef((*WrapCfgList_it)->EssenceDescriptor);

				MData->AddEssenceType((*WrapCfgList_it)->WrapOpt->WrappingUL);

				// Link the MP to the FP
				TrackInfoList.back()->MPClip->MakeLink(TrackInfoList.back()->FPTrack, 0);
			}
			else // !OPAtom, !FrameGroup
			{
				// Write a FileDescriptor
				// DRAGONS Can we ever need a MultipleDescriptor?
				ThisDescriptor->SetUInt(LinkedTrackID_UL, TrackInfoList.back()->FPTrack->GetUInt(TrackID_UL));

				// If this is multiple essence, only add the mux descriptor and essence type on the first sub-track
				if((!SubDescriptors) || (SubTrackIndex == 0))
				{
					FilePackage->AddChild(Descriptor_UL)->MakeRef((*WrapCfgList_it)->EssenceDescriptor);

					// Add the essence type
					MData->AddEssenceType((*WrapCfgList_it)->WrapOpt->WrappingUL);

					if((*WrapCfgList_it)->EssenceDescriptor->IsA(MultipleDescriptor_UL))
					{
						// Ensure that we have flagged a multiple descriptor if one is used
						ULPtr GCUL = new UL( mxflib::GCMulti_Data );
						MData->AddEssenceType( GCUL );
					}
				}

				// Link the MP to the FP
				TrackInfoList.back()->MPClip->MakeLink(TrackInfoList.back()->FPTrack, 0);
			}

			// Exit loop after a single iteration if not multiple essence
			if(!SubDescriptors) break;

			// Move to next sub-descriptor
			SubDescriptorsIt++;
			SubTrackIndex++;
			
			// DRAGONS: This may step off the end on the list, in fact it will for every time through in the first gang
			//          as we will not yet have added the duplicate track info for the next sub track. We could just add
			//          the duplication code here - but that would end up wrong if we don't add another sub track, for
			//          example when we hit the end of the sub track list. Instead we move the pointer back to the new entry
			//          later if this stepped us off the end
			TrackInfoIt++;
		};

		WrapCfgList_it++;
		iTrack++;

		// Set the gang size when we hit the end of the first gang
		if(iTrack == InFileGangSize) TracksPerGang = TrackInfoList.size();
	}


	//
	// ** Set up indexing **
	//

	if(UseIndex || SparseIndex || SprinkledIndex)
	{
		// Find all essence container data sets so we can update "IndexSID"
		MDObjectPtr ECDataSets = MData[ContentStorage_UL];
		if(ECDataSets) ECDataSets = ECDataSets->GetLink();
		if(ECDataSets) ECDataSets = ECDataSets[EssenceContainerDataBatch_UL];

		WrapCfgList_it = WrapCfgList.begin();
		BodyStreamList::iterator Streams_it = Streams.begin();
		iTrack=0;
		while((WrapCfgList_it != WrapCfgList.end()) && (Streams_it != Streams.end()))
		{
			// Only index it if we can
			// Currently we can only VBR index frame wrapped essence
			if(    ((*WrapCfgList_it)->WrapOpt->CBRIndex)
				|| (((*WrapCfgList_it)->WrapOpt->CanIndex) && ((*WrapCfgList_it)->WrapOpt->ThisWrapType == WrappingOption::Frame)))
			{
				if((!OPAtom) || (iTrack == OutFileNum))
				{
					UInt32 BodySID;				//! Body SID for this essence stream
					UInt32 IndexSID;			//! Index SID for the index of this essence stream

					// FrameGroup will use a single multi-stream index...
					if(FrameGroup)
					{
						BodySID = Streams.front()->GetBodySID();
						IndexSID = 129;
						Streams.front()->SetIndexSID(129);
					}
					// ...otherwise one per stream
					else
					{
						BodySID = (*Streams_it)->GetBodySID();
						IndexSID = iTrack + 129;
						(*Streams_it)->SetIndexSID(IndexSID);
					}

					// Update IndexSID in essence container data set
					if(ECDataSets)
					{
						MDObject::iterator ECD_it = ECDataSets->begin();
						while(ECD_it != ECDataSets->end())
						{
							if((*ECD_it).second->GetLink())
							{
								if((*ECD_it).second->GetLink()->GetUInt(BodySID_UL) == BodySID)
								{
									(*ECD_it).second->GetLink()->SetUInt(IndexSID_UL, IndexSID);
									break;
								}
							}
							ECD_it++;
						}
					}
				}
			}

			WrapCfgList_it++;
			iTrack++;
		}

	}


	//
	// ** Set up the base partition pack **
	//

	PartitionPtr ThisPartition = new Partition(OpenHeader_UL);
	ASSERT(ThisPartition);
	ThisPartition->SetKAG(KAGSize);			// Everything else can stay at default
	ThisPartition->SetUInt(BodySID_UL, 1);

	ThisPartition->AddMetadata(MData);

	// Build an Ident set describing us and link into the metadata
	MDObjectPtr Ident = new MDObject(Identification_UL);
	Ident->SetString(CompanyName_UL, CompanyName);
	Ident->SetString(ProductName_UL, ProductName);
	Ident->SetString(VersionString_UL, ProductVersion);
	Ident->SetString(ToolkitVersion_UL, LibraryProductVersion());
	Ident->SetString(Platform_UL, PlatformName);
	UUIDPtr ProductUID = new mxflib::UUID(ProductGUID_Data);

	// DRAGONS: -- Need to set a proper GUID per released version
	//             Non-released versions currently use a random GUID
	//			   as they are not a stable version...
	Ident->SetValue(ProductUID_UL, DataChunk(16,ProductUID->GetValue()));

	// Link the new Ident set with all new metadata
	// Note that this is done even for OP-Atom as the 'dummy' header written first
	// could have been read by another device. This flags that items have changed.
	MData->UpdateGenerations(Ident);

	// Add the template partition to the body writer
	Writer->SetPartition(ThisPartition);


	//
	// ** Process Essence **
	//


	// Write the header (open and incomplete so far)
	if(HeaderPadding) Writer->SetPartitionFiller(HeaderPadding);
	Writer->WriteHeader(false, false);

	// If we are writing OP-Atom update the OP label so that body partition packs claim to be OP-Atom
	// The header will remain as a generalized OP until it is re-written after the footer
	if(OPAtom) 
	{
		MData->SetOP(OPAtomUL);

		// Set top-level file package correctly for OP-Atom
		// DRAGONS: This will need to be changed if we ever write more than one File Package for OP-Atom!
		MData->SetPrimaryPackage(FilePackage);
	}

	// Write the body
	if(BodyMode == BodyWrapping::Body_None)
	{
		Writer->WriteBody();
	}
	else
	{
		while(!Writer->BodyDone())
		{
			if(BodyMode == BodyWrapping::Body_Duration)
				Writer->WritePartition(BodyRate, 0);
			else
				Writer->WritePartition(0, BodyRate);
		}
	}


	/** Write the footer **/

	// Update the modification time
	MData->SetTime();

	// Update all durations
	BodyStreamPtr IndexBaseStream;
	if( OPAtom ) 
	{
		// Locate the (OutFileNum)th stream - which should be the source we are wrapping for this file
		int i = OutFileNum;
		BodyStreamList::iterator it = Streams.begin();
		while((i--) && it != Streams.end()) it++;

		// Back off if we fell off the end of the list
		if(it == Streams.end()) it--;

		IndexBaseStream = *it;
	}
	else if( FrameGroup ) IndexBaseStream = Streams.front();
	else IndexBaseStream = Streams.front();

	Length EssenceDuration = (Length) IndexBaseStream->GetSource()->GetCurrentPosition();
	if(PutTCTrack)
		MPTimecodeComponent->SetDuration(EssenceDuration);

	iTrack = 0;						//  Essence container index
	WrapCfgList_it = WrapCfgList.begin();
	while(WrapCfgList_it != WrapCfgList.end())
	{
		if((!OPAtom) || (iTrack == OutFileNum))
		{
			if(PutTCTrack)
				if((iTrack==0) || (!FrameGroup)) FPTimecodeComponent[iTrack]->SetDuration(EssenceDuration);
			(*WrapCfgList_it)->EssenceDescriptor->SetInt64(ContainerDuration_UL,EssenceDuration);
		}
			
		WrapCfgList_it++;
		iTrack++;
	}

	EssenceTrackInfoList::iterator TrackInfoIt = TrackInfoList.begin();
	while(TrackInfoIt != TrackInfoList.end())
	{
		if((*TrackInfoIt)->MPClip) (*TrackInfoIt)->MPClip->SetDuration(EssenceDuration);
		if((*TrackInfoIt)->FPClip) (*TrackInfoIt)->FPClip->SetDuration(EssenceDuration);
		TrackInfoIt++;
	}

	// Update the generation UIDs in the metadata to reflect the changes
	MData->UpdateGenerations(Ident);

	// Make sure any new sets are linked in
	ThisPartition->UpdateMetadata(MData);

	
	// Actually write the footer
	// Note: No metadata in OP-Atom footer
	if(OPAtom) Writer->WriteFooter(false);
	else Writer->WriteFooter(true, true);


	//
	// ** Update the header ** 
	//
	// For generalized OPs update the value of "FooterPartition" in the header pack
	// For OP-Atom re-write the entire header
	//

	UInt64 FooterPos = ThisPartition->GetUInt64(FooterPartition_UL);
	Out->Seek(0);

	if(UpdateHeader)
	{
		// Read the old partition to allow us to keep the same KAG and SIDs
		PartitionPtr OldHeader = Out->ReadPartition();

		// Read any index table data
		DataChunkPtr IndexData = OldHeader->ReadIndexChunk();

		// Now update the partition we are about to write (the one with the metadata)
		ThisPartition->ChangeType(ClosedCompleteHeader_UL);
		ThisPartition->SetUInt64(FooterPartition_UL, FooterPos);
		ThisPartition->SetKAG(OldHeader->GetUInt(KAGSize_UL));
		ThisPartition->SetUInt(IndexSID_UL, OldHeader->GetUInt(IndexSID_UL));
		ThisPartition->SetUInt64(BodySID_UL, OldHeader->GetUInt(BodySID_UL));

		Out->Seek(0);
		if(IndexData)
			Out->ReWritePartitionWithIndex(ThisPartition, IndexData);
		else
			Out->ReWritePartition(ThisPartition);
	}
	else
	{
		ThisPartition = Out->ReadPartition();
		ThisPartition->SetUInt64(FooterPartition_UL, FooterPos);
		Out->Seek(0);
		Out->WritePartitionPack(ThisPartition);
	}

	return Ret;
}

